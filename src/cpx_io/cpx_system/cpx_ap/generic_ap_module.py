import json
from dataclasses import dataclass
from cpx_io.cpx_system.cpx_base import CpxBase
from cpx_io.cpx_system.cpx_ap.cpx_ap_module import CpxApModule
from cpx_io.utils.boollist import bytes_to_boollist, boollist_to_bytes
from cpx_io.utils.helpers import div_ceil, channel_range_check
from cpx_io.utils.logging import Logging

@dataclass
class Channel:
    bits : int
    channel_id : int
    data_type : str
    description : str
    direction : str
    name : str
    profile_list : list

@dataclass
class ChannelGroup:
    channel_group_id : int
    channels : dict
    name : str
    parameter_group_ids : list

class ChannelGroupBuilder:
    def build_channel_group(self, channel_group_dict):
        return ChannelGroup(channel_group_dict.get("ChannelGroupId"), 
                            channel_group_dict.get("Channels"),
                            channel_group_dict.get("Name"), 
                            channel_group_dict.get("ParameterGroupIds"),
                            )

class ChannelBuilder:
     def build_channel(self, channel_dict):
        return Channel(channel_dict.get("Bits"), 
                        channel_dict.get("ChannelId"),
                        channel_dict.get("DataType"), 
                        channel_dict.get("Description"),
                        channel_dict.get("Direction"), 
                        channel_dict.get("Name"), 
                        channel_dict.get("ProfileList"),
                        )
              

class GenericApModule(CpxApModule):
    
    ########### TODO: this is just for testing! must be moved to instance 
    # attribute later and generated by apdd
    module_codes = {12290: "generic_test"}
    ###########

    def __init__(self, *args, apdd_path=None,**kwargs):
        super().__init__(*args, **kwargs)

        ########### TODO: this is just for testing! delete later and put where adding the module
        if not apdd_path:
            apdd_path = "src/cpx_io/cpx_system/cpx_ap/apdd/CPX-AP-A-12DI4DO-M12-5P.json"
        ###########

        if apdd_path:
            with open(apdd_path, 'r', encoding='utf-8') as f:
                apdd = json.load(f)

            # set module code(s)
            self.module_codes = {}
            for variant in apdd["Variants"]["VariantList"]:
                self.module_codes[variant["VariantIdentification"]["ModuleCode"]] = variant["VariantIdentification"]["OrderText"]

            # setup all channel types
            channel_types = []
            for channel_dict in apdd["Channels"]:
                channel_types.append(ChannelBuilder().build_channel(channel_dict))

            Logging.logger.debug(f"Set up Channel Types: {channel_types}")

            # setup all channel groups
            channel_groups = []
            for channel_group_dict in apdd["ChannelGroups"]:
                channel_groups.append(ChannelGroupBuilder().build_channel_group(channel_group_dict))

            Logging.logger.debug(f"Set up Channel Groups: {channel_groups}")

            # setup all channels for the module
            channels = []
            for channel_group in channel_groups:
                for channel in channel_group.channels:
                    for channel_type in channel_types:
                        if channel_type.channel_id == channel.get("ChannelId"):
                            break
                    
                    for _ in range(channel["Count"]):
                        channels.append(channel_type)

            Logging.logger.debug(f"Set up Channels: {channels}")

            # split in in/out channels and set instance variables
            self.input_channels = [c for c in channels if c.direction=="in"]
            self.output_channels = [c for c in channels if c.direction=="out"]

    def __getitem__(self, key):
        return self.read_channel(key)

    def __setitem__(self, key, value):
        self.write_channel(key, value)

    @CpxBase.require_base
    def read_channels(self):
        # if available, read inputs
        values = []
        if self.input_channels:
            data = self.base.read_reg_data(self.input_register, 
                                           length=div_ceil(self.information.input_size, 2))
            if all(c.data_type == "BOOL" for c in self.input_channels):
                values.extend(bytes_to_boollist(data)[:len(self.input_channels)])

        # if available, read outputs
        if self.output_channels:
            data = self.base.read_reg_data(self.output_register, 
                                           length=div_ceil(self.information.output_size, 2))
            if all(c.data_type == "BOOL" for c in self.output_channels):
                values.extend(bytes_to_boollist(data)[:len(self.output_channels)])

        Logging.logger.info(f"{self.name}: Reading channels: {values}")
        return values
    
    # TODO: This is very unique with the output numbering. Maybe this needs to be omitted
    @CpxBase.require_base
    def read_channel(self, channel: int, output_numbering=False) -> bool:
        """read back the value of one channel
        Optional parameter 'output_numbering' defines
        if the outputs are numbered with the inputs ("False", default),
        so the range of output channels is 12..15 (as 0..11 are the input channels).
        If "True", the outputs are numbered from 0..3, the inputs cannot be accessed this way.

        :param channel: Channel number, starting with 0
        :type channel: int
        :param output_numbering: Set 'True' if outputs should be numbered from 0 ... 3, optional
        :type output_numbering: bool
        :return: Value of the channel
        :rtype: bool
        """
        if output_numbering:
            channel += 12

        return self.read_channels()[channel]
    
    @CpxBase.require_base
    def write_channels(self, data: list) -> None:
        """write all channels with a list of values

        :param data: list of values for each output channel
        :type data: list
        """
        if len(data) != len(self.output_channels):
            raise ValueError(f"Data must be list of {len(self.output_channels)} elements")
        
        if self.output_channels:
            if all(c.data_type == "BOOL" for c in self.output_channels) and all(isinstance(d, bool) for d in data):
                reg = boollist_to_bytes(data)
            else:
                raise NotImplementedError(f"{self.output_channels.data_type} is not supported")
            
            self.base.write_reg_data(reg, self.output_register)
            Logging.logger.info(f"{self.name}: Setting channels to {data}")
                                           
        else:
            raise NotImplementedError(f"Module {self.information.order_text} has no outputs to write to")


    # TODO: datatypes according to module?
    @CpxBase.require_base
    def write_channel(self, channel: int, value: bool|int|bytes) -> None:
        """set one channel value

        :param channel: Channel number, starting with 0
        :type channel: int
        :value: Value that should be written to the channel
        :type value: bool
        """
        if self.output_channels:
            channel_range_check(channel, self.output_channels)

            if all(c.data_type == "BOOL" for c in self.output_channels) and all(isinstance(d, bool) for d in data):
                data = bytes_to_boollist(self.base.read_reg_data(self.output_register))
                data[channel] = value
                reg = boollist_to_bytes(data)
                self.base.write_reg_data(reg, self.output_register)
            
                Logging.logger.info(f"{self.name}: Setting channel {channel} to {value}")

            else:
                raise NotImplementedError(f"{self.output_channels.data_type} is not supported")
            
        else:
            raise NotImplementedError(f"Module {self.information.ordercode} has no outputs to write to")
    
    @CpxBase.require_base
    def set_channel(self, channel: int) -> None:
        """set one channel to logic high level

        :param channel: Channel number, starting with 0
        :type channel: int
        """
        self.write_channel(channel, True)

    @CpxBase.require_base
    def clear_channel(self, channel: int) -> None:
        """set one channel to logic low level

        :param channel: Channel number, starting with 0
        :type channel: int
        """
        self.write_channel(channel, False)

    @CpxBase.require_base
    def toggle_channel(self, channel: int) -> None:
        """set one channel the inverted of current logic level

        :param channel: Channel number, starting with 0
        :type channel: int
        """
        # get the relevant value from the register and write the inverse
        value = self.read_channel(channel)
        self.write_channel(channel, not value)

if __name__ == "__main__":
    Logging(logging_level="DEBUG")
    test = GenericApModule("src/cpx_io/cpx_system/cpx_ap/apdd/CPX-AP-A-12DI4DO-M12-5P.json")
